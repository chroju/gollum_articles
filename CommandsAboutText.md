テキスト処理コマンド
========

* [Linuxテキスト編集コマンドのすべて - Qiita](http://qiita.com/KENJU/items/5777322e485a30aa6269)

使い分け
----

* `sed` 置換、削除
* `tr` 置換、変換（小文字を大文字に、等）
* `awk` 二次元テーブルの抽出、編集等

sed
----

単なる置換コマンドと考えると本質を見誤る。与えられたテキストを「パターンスペース」に1行ずつ読み込み、与えられたスクリプトによる処理を行なった上で出力することを、全行文繰り返すというアクションをする。例えば`-n`オプションを使うとパターンスペースの自動出力が抑制されるため、スクリプト部分で`p`などによりパターンスペースの出力を明示しなければ何も出力されなくなる。またホールドスペースと呼ばれる別のバッファを持っており、パターンスペースの内容をホールドスペースに退避することなどにより、複雑な処理も可能となる。

標準入力の処理が可能だが、`-i`オプションを遣うことで引数に指定したファイルを直接上書きする。バックアップを取る場合は拡張子を指定できる。

```bash
# 標準入力（ファイルは書き換えない）
$ cat foo.txt > sed -e 's/bar/baz/g'
# 引数で提示したファイルを上書き。
$ sed -i -e 's/bar/baz/g' foo.txt
# バックアップを取って上書き。
$ sed -i.bak -e 's/bar/baz/g' foo.txt
$ ls
foo.txt foo.txt.bak
```

基本的なイディオム
```bash
# 全置換
$ sed -e 's/foo/bar/g'
# 3行目に置換をかける
$ sed -e 's/foo/bar/3'
# 5～10行目に置換をかける
$ sed -e '5,10s/foo/bar/g'
# 複数パターンの置換
$ sed -e 's/foo/bar/;s/baz/quz/'
# 1文字ずつ置換
$ echo -e "foobar" | sed 'y/oa/01/' # f00b1r
# 3行目の後ろに追加
$ sed -e '3a\foo' bar.txt
# 末行に追加
$ sed -e '$a\foo' bar.txt
```

行操作は以下。意味としては`-n`オプションがパターンスペースの自動出力抑制であり、`p`が現在のパターンスペース出力である。つまりパターンスペース全体の出力を抑制した上で、`''`で指定した部分のみを表示させている。例えば`sed -n -e 's/foo/bar/p'`は置換した部分のみの出力となる（全体出力は`-n`で抑制され、`p`で置換結果だけが出力されている）。

```bash
# 行削除
$ sed -e '1d'
$ sed -e '1,3d'
# 行表示
$ sed -n '1,3p'
```

xml, htmlのタグ全削除
```bash
$ sed -e 's/<[^>]*>//g'
```
空行削除
```bash
$ sed -e '/^ *$/d'
# 正規表現の該当行削除なので、例えば以下だとhogeを含む行がすべて削除される
$ sed -e '/hoge/d'
```
後方参照
```bash
$ sed -e 's/abc(.*)def/\1_/g'
```

### 参考

* [ワンライナーでお手軽実行可能なsed入門 - Qiita](http://qiita.com/muran001/items/472abcfc353d5df7b77a)
* [26.3.5 ホールドスペースの使い方 | HWB](http://hwb.ecc.u-tokyo.ac.jp/current/applications/textprocessing/sed/holdspace/)

tr
----

改行削除
```bash
$ tr -d '\r'
```

awk
----

* テキストに対して高度な処理を行える。メカニズムとしては、`awk pattern action`の形で記述され、標準入力のテキストを1行ずつ`pattern`と照合し、合致した部分について`action`を実行して出力していく。`pattern`を省略した場合はすべてのテキスト、`action`を省略した場合は`pattern`に合致したすべてのテキストが出力対象となる。
* 評価は各列に対して行う。組み込み変数`$1`で1行目を指す。`$0`は全行が対象となる。行のデリミタとしては、デフォルトではスペースが認識される。
* patternとしては正規表現のほか、式によるマッチング、`BEGIN`と`END`による全体の開始前、終了後の処理を指定できる。
* actionは`print`文による出力がよく使われる。

```bash
# 2番目のカラムのみ表示
$ awk '{print $2}'
# $0は引数全体
$ awk '{print $0}'
```

出力行の限定。`NR`がawkの組み込み変数であり、行番号を表す。

```bash
$ awk 'NR==2'
$ awk 'NR>=2'
```

条件に該当する場合のみ表示。ここでは2行目が1.0以上の場合のみ表示。

```bash
$ awk '$2 > 1.0 {print}'
```

合計。1列目と2列目の数値合計を表示する。

```bash
$ awk '{a += $1; b += $2} END {print a, b}'
```

### オプション関連

* `-F` デリミタの指定。
* `-v` 変数の指定。`OFS`（出力時のデミリタ）など。

### ダブルクォートを使ってはならない

`$1`がシェルに引数として判定されるから。`su -c`でダブルクォート内に`awk`書いて見事にハマった。

[awk のハマるポイントまとめ - Qiita](http://qiita.com/aibou/items/159a18ca70ac87b40bad)

### 数値の出力

デフォルトだと指数表記になるため、OFMTによって調整する。

[awkでの数値演算注意 - Yahoo! JAPAN Tech Blog](http://techblog.yahoo.co.jp/web/auctions/awk/)

### 参照

* [AWK Users JP :: awk 基礎文法最速マスター](http://gauc.no-ip.org/awk-users-jp/blis.cgi/awk_fastest)

grep
----

キーワードを含む行と、その次の行を抜き出す。例えば
```html
...
<div id="main">
    <p>メインのテキストです</p>
</div>
...
```
というHTMLがあり、テキストを抜き出したい場合に
```bash
$ cat example.html | grep -A 1 'id="main"' | sed 's/<p>(.*)<\/p>/\1_/g'
```
とする。`grep`の`-A n`オプションは、一致行の後n行を一緒に抜き出すオプションであり、前行を抜き出す場合は同様に`-B`が使える。前後両方を抜き出すには`-C`なのだが、もうちょいマシなネーミングはなかったのかと正直思いはする。

その後`sed`で`p`タグの中身だけ後方参照を使って抜き出している。

### AND検索

* 愚直にパイプで繋いでいく。

```bash
$ cat foo | grep bar | grep baz
```

cut
----

* `-d` デリミタの指定（デフォルトではタブ）
* `-f` 抽出する列番号の指定

```bash
$ cat sample.txt
01 foo bar 29 S
$ cat sample.txt | cut -d ' ' -f 2,4
foo 29
```

# その他
重複行排除
```bash
$ cat foo.txt | sort | uniq
```
* 完全一致する行を排除する。
* 比較は隣接行同士のみのため、`sort`しておくことが必須。

文字コードの変更（SJISからutf-8へ）
```bash
$ iconv -f 'SJIS' -t 'UTF-8'
```
